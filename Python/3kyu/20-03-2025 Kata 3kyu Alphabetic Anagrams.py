"""Рассмотрим «слово» как любую последовательность заглавных букв от A до Z 
(не ограничиваясь только «словарными словами»). 
Для любого слова, состоящего как минимум из двух разных букв, существуют другие слова, 
состоящие из тех же букв, но в другом порядке 
(например, STATIONARILY/ANTIROYALIST, которые являются словарными словами; 
для наших целей «AAIILNORSTTY» также является «словом», состоящим из тех же букв, что и эти два).

Затем мы можем присвоить каждому слову номер в зависимости от того, 
на каком месте оно находится в отсортированном по алфавиту списке всех слов, 
состоящих из той же группы букв. Один из способов сделать это — 
сгенерировать весь список слов и найти нужное, но это займёт много времени, если слово длинное.

Учитывая слово, верните его номер. Ваша функция должна принимать любое слово длиной 25 символов или 
меньше (возможно, с повторяющимися буквами) и выполняться не более чем за 500 миллисекунд. Для сравнения: 
выполнение 27 тестовых случаев в коде решения на JS занимает 101 миллисекунду.

Для очень длинных слов в JS могут возникнуть проблемы с точностью чисел (если позиция слова больше 2^53). 
Для тестов JS с большими позициями есть небольшая погрешность (0,000000001%). 
Если вам кажется, что вы правильно определяете позиции для меньших рангов, 
но ошибаетесь при округлении для больших рангов, отправьте запрос ещё пару раз и посмотрите, поможет ли это.

В Python, Java и Haskell можно задавать произвольную точность для целых чисел, 
поэтому в этих языках нужно быть точным (если только кто-нибудь меня не поправит).

C # использует a long , который, возможно, не обладает лучшей точностью, но тесты заблокированы, 
поэтому мы не можем его изменить.

Примеры слов с их рейтингом:
ABAB = 2
AAAB = 1
BAAA = 4
ВОПРОС = 24572
БИБЛИОТЕКАРЬ = 10743"""

def list_position(word):
    """Return the anagram list position of the word"""
    return 1