"""Создайте функцию, которая принимает положительное целое число и возвращает следующее большее число, 
которое можно получить, переставив его цифры. Например:

  12 ==> 21
 513 ==> 531
2017 ==> 2071
Если цифры нельзя переставить так, чтобы получилось большее число, 
верните -1 (или nil в Swift, None в Rust):

  9 ==> -1
111 ==> -1
531 ==> -1"""

def next_bigger(n):
    digits = list(str(n))
    i = len(digits) - 2
    # Ищем точку i, где digits[i] < digits[i+1]
    while i >= 0 and digits[i] >= digits[i+1]:
        i -= 1
    if i == -1:
        return -1  # Невозможно сделать больше

    # Ищем j, наибольший индекс справа от i, где digits[j] > digits[i]
    j = len(digits) - 1
    while digits[j] <= digits[i]:
        j -= 1

    # Меняем местами i и j
    digits[i], digits[j] = digits[j], digits[i]

    # Переворачиваем оставшуюся часть после i
    digits[i+1:] = reversed(digits[i+1:])

    # Преобразуем обратно в число
    next_num = int(''.join(digits))

    return next_num

print(next_bigger(12))

"""Давайте разберем код функции `next_bigger` пошагово, чтобы понять, как она работает:

### Цель функции
Функция `next_bigger` принимает целое число `n` и возвращает следующее большее число, 
которое можно получить перестановкой цифр числа `n`. Если такое число невозможно, функция возвращает `-1`.

### Пошаговое объяснение

1. **Преобразование числа в список цифр:**
   ```python
   digits = list(str(n))
   ```
   Число `n` преобразуется в строку, а затем в список цифр. Например, если `n = 123`, 
   то `digits` станет `['1', '2', '3']`.

2. **Поиск точки разрыва:**
   ```python
   i = len(digits) - 2
   while i >= 0 and digits[i] >= digits[i+1]:
       i -= 1
   if i == -1:
       return -1
   ```
   - Мы ищем такую позицию `i`, где `digits[i] < digits[i+1]`. 
   Это позволяет найти точку, где цифры начинают убывать.
   - Если такой позиции нет (`i == -1`), это означает, 
   что число уже максимально возможное (например, `321`), и нет способа сделать его больше. 
   В этом случае функция возвращает `-1`.

3. **Поиск цифры для обмена:**
   ```python
   j = len(digits) - 1
   while digits[j] <= digits[i]:
       j -= 1
   ```
   - Мы ищем самую правую цифру `digits[j]`, которая больше `digits[i]`. 
   Это позволяет минимизировать изменения при перестановке.

4. **Обмен цифр:**
   ```python
   digits[i], digits[j] = digits[j], digits[i]
   ```
   - Меняем местами `digits[i]` и `digits[j]`. Это создает минимально возможное число, 
   большее `n`, с учетом текущей перестановки.

5. **Переворот хвоста:**
   ```python
   digits[i+1:] = reversed(digits[i+1:])
   ```
   - Переворачиваем часть списка после позиции `i`. Это гарантирует, 
   что оставшаяся часть числа является минимально возможной перестановкой.

6. **Преобразование обратно в число:**
   ```python
   next_num = int(''.join(digits))
   ```
   - Преобразуем список цифр обратно в строку, а затем в целое число.

7. **Возврат результата:**
   ```python
   return next_num
   ```
   - Возвращаем полученное число.

### Пример

Рассмотрим пример с числом `123`.

- `digits = ['1', '2', '3']`
- `i = 1` (так как `digits[1] < digits[2]`)
- `j = 2` (так как `digits[2] > digits[1]`)
- После обмена: `digits = ['1', '3', '2']`
- Переворот хвоста: `digits = ['1', '3', '2']` (в данном случае хвост уже минимален)
- Результат: `next_num = 132`

Таким образом, функция возвращает `132` как следующее большее число после `123`."""